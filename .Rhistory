df <- filter(df, Month == ymd("2011-09-01")) #!=
numslots.section <- df %>%
group_by(Month, Casino, Section) %>%
summarise(sum = sum(numero_macchine),
ricavo = sum(ricavi_totali)) %>%
#il mutate perde un livello dopo il summarise
mutate(sum_casino = sum(sum), prop_per_mese = round(sum / sum(sum), 3))
# ggplot(data = numslots.section, aes(x = sum, y = prop_per_mese)) +
#   geom_point(aes(color = Casino, size = ricavo)) +
#   ggtitle("Distribuzione della proporzione del numero di slot sul totale del casino per ogni mese") +
#   xlab("Numero slot per sezione (per mese)") +
#   ylab("Proporzione di slot in ogni mese") #+ facet_wrap(~Section)
#Ottieni numero di slot presenti in ogni casino per mese da usare come upper bound
numslots.casino <- NULL #a cosa serve ?
nslots <- df %>%
group_by(Month, Casino) %>%
summarise(sum = sum(numero_macchine)) %>%
arrange(Month) #ensure order
nslots <- nslots$sum #numero di slot per casino e mese
f.obj <- round(df$ricavo_unitario)
#First create dummy var for Casino and month, used to activate each constraint depending on the casino and month
f.A1 <- t(predict(dummyVars(~ Casino, data = df), newdata = df))
#View(rbind(t(df[, "Casino"]), t(df$Month), f.A)) #Check results
#with one month don't require " : I(factor(Month)" after Casino
#Coefficients
b1 <- nslots #month1-> casino1, month1 ->casino2, month2 -> casino1, ...
f.b1 <-  b1 #vector of right-hand side values - upper bounds of total number of slots per month
f.dir1 <- rep("<=", length(f.b1)) # direction of the inequalities
sol1 <- solveLP(f.obj, f.b1, f.A1, maximum = TRUE, const.dir = f.dir1) #solver
sol1bis <- lp(direction = "max", objective.in = f.obj, const.mat = f.A1, const.dir = f.dir1, const.rhs = f.b1)
sol1$con
sol1$solution
f.A2 <- t(predict(dummyVars(~ Section : Casino, data = df), newdata = df))
#with one month don't require " : factor(Month)" after Casino
# Duplicate every row, needed because for each section/month/casino we need a lower and upper bound.
# Retain order --> ob1-low, obs1-up, obs2-low, ...)
f.A2 <- as.tibble(f.A2) %>% slice(rep(1:n(), each = 2)) %>% as.matrix()
#I vincoli sono attivati nel seguente modo
# mese1-casino1-sez1-low,
# mese1-casino1-sez1-up,
# mese1-casino1-sez2;
# mese1-casino2;
# mese2;...
# quindi i primi 8 (4 sez * 2 up/low) vincoli sono associato ad un medesimo upper e lower bound, legato al primo valore di nslots.
#nslots contiene il numero di slot per ogni casino e mese, alternato per casino (mese1 casino1, mese1 casino2, mese2 casino1, ...)
# combine nslots in two columns, where rows are months and columns are casino (first for Aries)
(numslots <- matrix(nslots, ncol = 2, byrow = T))
f.b2 <- c()
month_prop <- numslots.section %>%
group_by(Month, Casino) %>% summarise(prop_min = min(prop_per_mese),
prop_max = max(prop_per_mese))
b2 <- cbind(nslots, month_prop$prop_min, month_prop$prop_max)
colnames(b2) <- NULL #altrimenti errore nel solver
# to check correctness, compare with
#View(numslots.section)
f.b2 <- c()
# probabilmente si puo' fare senza il ciclo for, ma come??
for (i in 1:nrow(b2)) {
f.b2 <- c(f.b2, rep(round(c(b2[i,1]*b2[i,2], b2[i,1]*b2[i,3])), 4))
}
f.dir2 <- rep(c(">=", "<="), length(f.b2)/2) # direction of the inequalities
sol2 <- solveLP(f.obj, f.b2, f.A2, maximum = TRUE, const.dir = f.dir2) #solver
sol2bis <- lp(direction = "max", objective.in = f.obj, const.mat = f.A2, const.dir = f.dir2, const.rhs = f.b2)
summary(sol2)
sol2$con
#Calcola i bin per le giocate totali del casino Libra, per differenziare dai bin di Aries
quartili.aries <- c(quantile(df[df$Casino == "Aries", ]$"giocate_totali", probs = seq(0, 1, by = 0.25)))
quartili.libra <- c(quantile(df[df$Casino == "Libra", ]$"giocate_totali", probs = seq(0, 1, by = 0.25)))
#Check dataset ordering --> arrange(Month, Section, MachineType, Denomination, Casino)
head(df, n = 100)
head(arrange(df, Month, Section, MachineType, Denomination, Casino), n = 100) #ok, e' cosi'
# split dataset based on casino, to differentiate bins
aries.idx <- which(df$Casino == "Aries")
aries <- df[aries.idx,]
libra <- df[-aries.idx,]
# Create bins based on total plays, include lowest value, and display digits instead of scientific notation
aries$bin_giocate <- cut(aries$giocate_totali, breaks = quartili.aries, include.lowest = T, dig.lab=10)
libra$bin_giocate <- cut(libra$giocate_totali, breaks = quartili.libra, include.lowest = T, dig.lab=10)
# merge the two casino into the original dataset, with the additional column bin_giocate
df <- rbind(aries, libra) %>% arrange(Month, Section, MachineType, Denomination, Casino)
# reorder columns, set bin_giocate next to giocate_totali
df[c(1:9, 13, 10:12)]
# Confirm ordering is the same as before
all(which(df$Casino == "Aries") == aries.idx)
bin_stats <- df %>%
group_by(bin_giocate, Casino) %>%
summarise(minimo_macchine = min(numero_macchine),
massimo_macchine = max(numero_macchine),
media_macchine = mean(numero_macchine),
mediana_macchine = median(numero_macchine),
totale_macchine = sum(numero_macchine)) %>%
#arrange(Casino, desc(bin_giocate)) #non funziona bene come ordinamento
arrange(Casino, media_macchine) #meglio
#Non funzia
par(mfrow = c(2, 4))
for (b in unique(df$bin_giocate)) {
ggplot(data = df[df$bin_giocate == b,], aes(x = "b", y = numero_macchine)) +
geom_boxplot()
}
par(mfrow = c(1,1))
f.A3 <- diag(nrow(df))
f.A3 <- as.tibble(f.A3) %>% slice(rep(1:n(), each = 2)) %>% as.matrix()
b <- c()
for (i in 1:nrow(df)) {
#get the correct row index to identify the bin reference
idx <- match(df[i,"bin_giocate"], bin_stats$bin_giocate)
# create vector of constraint coefficient, lower then upper bounds
b <- append(b, bin_stats[idx, "minimo_macchine"])
b <- append(b, bin_stats[idx, "massimo_macchine"])
}
f.b3 <- unlist(b, use.names=FALSE)
f.dir3 <- rep(c(">=", "<="), dim(df)[1]) # direction of the inequalities
#check if A3 is equal to f.A3 -> all(A3 == f.A3) FALSE
f.A <- rbind(f.A1, f.A2, f.A3)
f.b <- c(f.b1, f.b2, f.b3)
f.dir <- c(f.dir1, f.dir2, f.dir3)
sol <- solveLP(f.obj, f.b, f.A, maximum = TRUE, const.dir = f.dir) #solver
sol.bis <- lp(direction = "max", objective.in = f.obj, const.mat = f.A, const.dir = f.dir, const.rhs = f.b)
sol$solution
sol.bis
summary(sol)
shadow_price <- sol$con
View(shadow_price)
View(df)
# load r object with the solutions for each month
load("solutions.RData")
sol <- sols$`2011-09-01`
shadow_price <- sol$con
vincolo1 <- shadow_price[1:2,]
knitr::kable(vincolo1)
vincolo2 <- shadow_price[3:18,]
knitr::kable(vincolo2)
View(sol)
vincolo2 <- shadow_price[3:18,]
knitr::kable(vincolo2)
library(tidyverse)
library(lubridate)
library(caret)
library(linprog)
options(scipen = 999)
slot <- readxl::read_excel("Lucky Duck Entertainment revenue 2013.xls", na = c(".", "NA", "NaN"))
str(slot)
df <- slot %>%
group_by(Month, Casino, Section, MachineType, Denomination) %>%
summarise(numero_macchine    = sum(NoMachines),
ricavi_totali      = sum(GrossRevenue),
ricavo_unitario    = ricavi_totali/numero_macchine,
giocate_totali     = sum(Plays),
giocate_unitarie   = round(giocate_totali/numero_macchine),
ricavo_per_giocata = ricavi_totali/giocate_totali) %>%
arrange(Month, Section, MachineType, Denomination) %>%
mutate(tipo = paste0(MachineType, "_", Denomination))
head(df)
# df %>% ggplot(aes(x = giocate_totali, y = ricavo_per_giocata)) +
#   geom_point()
# df[df$"ricavo_per_giocata" > 5,]
df <- filter(df, Month == ymd("2011-09-01")) #!=
numslots.section <- df %>%
group_by(Month, Casino, Section) %>%
summarise(sum = sum(numero_macchine),
ricavo = sum(ricavi_totali)) %>%
#il mutate perde un livello dopo il summarise
mutate(sum_casino = sum(sum), prop_per_mese = round(sum / sum(sum), 3))
# ggplot(data = numslots.section, aes(x = sum, y = prop_per_mese)) +
#   geom_point(aes(color = Casino, size = ricavo)) +
#   ggtitle("Distribuzione della proporzione del numero di slot sul totale del casino per ogni mese") +
#   xlab("Numero slot per sezione (per mese)") +
#   ylab("Proporzione di slot in ogni mese") #+ facet_wrap(~Section)
#Ottieni numero di slot presenti in ogni casino per mese da usare come upper bound
numslots.casino <- NULL #a cosa serve ?
nslots <- df %>%
group_by(Month, Casino) %>%
summarise(sum = sum(numero_macchine)) %>%
arrange(Month) #ensure order
nslots <- nslots$sum #numero di slot per casino e mese
f.obj <- round(df$ricavo_unitario)
#First create dummy var for Casino and month, used to activate each constraint depending on the casino and month
f.A1 <- t(predict(dummyVars(~ Casino, data = df), newdata = df))
#View(rbind(t(df[, "Casino"]), t(df$Month), f.A)) #Check results
#with one month don't require " : I(factor(Month)" after Casino
#Coefficients
b1 <- nslots #month1-> casino1, month1 ->casino2, month2 -> casino1, ...
f.b1 <-  b1 #vector of right-hand side values - upper bounds of total number of slots per month
f.dir1 <- rep("<=", length(f.b1)) # direction of the inequalities
sol1 <- solveLP(f.obj, f.b1, f.A1, maximum = TRUE, const.dir = f.dir1) #solver
sol1bis <- lp(direction = "max", objective.in = f.obj, const.mat = f.A1, const.dir = f.dir1, const.rhs = f.b1)
sol1$con
sol1$solution
f.A2 <- t(predict(dummyVars(~ Section : Casino, data = df), newdata = df))
#with one month don't require " : factor(Month)" after Casino
# Duplicate every row, needed because for each section/month/casino we need a lower and upper bound.
# Retain order --> ob1-low, obs1-up, obs2-low, ...)
f.A2 <- as.tibble(f.A2) %>% slice(rep(1:n(), each = 2)) %>% as.matrix()
#I vincoli sono attivati nel seguente modo
# mese1-casino1-sez1-low,
# mese1-casino1-sez1-up,
# mese1-casino1-sez2;
# mese1-casino2;
# mese2;...
# quindi i primi 8 (4 sez * 2 up/low) vincoli sono associato ad un medesimo upper e lower bound, legato al primo valore di nslots.
#nslots contiene il numero di slot per ogni casino e mese, alternato per casino (mese1 casino1, mese1 casino2, mese2 casino1, ...)
# combine nslots in two columns, where rows are months and columns are casino (first for Aries)
(numslots <- matrix(nslots, ncol = 2, byrow = T))
f.b2 <- c()
month_prop <- numslots.section %>%
group_by(Month, Casino) %>% summarise(prop_min = min(prop_per_mese),
prop_max = max(prop_per_mese))
b2 <- cbind(nslots, month_prop$prop_min, month_prop$prop_max)
colnames(b2) <- NULL #altrimenti errore nel solver
# to check correctness, compare with
#View(numslots.section)
f.b2 <- c()
# probabilmente si puo' fare senza il ciclo for, ma come??
for (i in 1:nrow(b2)) {
f.b2 <- c(f.b2, rep(round(c(b2[i,1]*b2[i,2], b2[i,1]*b2[i,3])), 4))
}
f.dir2 <- rep(c(">=", "<="), length(f.b2)/2) # direction of the inequalities
sol2 <- solveLP(f.obj, f.b2, f.A2, maximum = TRUE, const.dir = f.dir2) #solver
sol2bis <- lp(direction = "max", objective.in = f.obj, const.mat = f.A2, const.dir = f.dir2, const.rhs = f.b2)
summary(sol2)
sol2$con
View(f.A2)
View(f.A2)
View(df)
4959*39
9447*21
vincolo3 <- shadow_price[19:length(shadow_price[,1]),]
rownames(vincolo3) <- 1:length(vincolo3[,1])
knitr::kable(head(vincolo3))
knitr::kable(vincolo3[vincolo3$actual == vincolo3$bvec & vincolo3$dir == "<=", ])
# load r object with the solutions for each month
load("solutions.RData")
vincoli.names <- with(df, paste(Casino,Section,MachineType,Denomination, sep="_"))
first <- c("Aries", "Libra")
second <- expand.grid(c('low', 'up'), unique(df$Section), unique(df$Casino))
concat <- function(x) paste0(x[,2], '_', x[,3], '.', x[,1])
second <- concat(second)
third <- expand.grid(c('low','up'), vincoli.names)
third <- with(third, paste(Var2, Var1, sep = "."))
help("WITH")
help(with)
View(concat)
sol <- sols$`2011-09-01`
rownames(sol$con) <- c(first, second, third)
vincoli.names <- with(df, paste(Casino,Section,MachineType,Denomination, sep="_"))
first <- c("Aries", "Libra")
second <- expand.grid(c('low', 'up'), unique(df$Section), unique(df$Casino))
concat <- function(x) paste0(x[,2], '_', x[,3], '.', x[,1])
second <- concat(second)
third <- expand.grid(c('low','up'), vincoli.names)
third <- with(third, paste(Var2, Var1, sep = "."))
sol <- sols$`2011-09-01`
rownames(sol$con) <- c(first, second, third)
# load r object with the solutions for each month
load("solutions.RData")
vincoli.names <- with(df, paste(Casino,Section,MachineType,Denomination, sep="_"))
first <- c("Aries", "Libra")
second <- expand.grid(c('low', 'up'), unique(df$Section), unique(df$Casino))
concat <- function(x) paste0(x[,2], '_', x[,3], '.', x[,1])
second <- concat(second)
third <- expand.grid(c('low','up'), vincoli.names)
third <- with(third, paste(Var2, Var1, sep = "."))
library(lubridate)
df <- df %>% filter(Month == ymd())
df <- df %>% filter(Month == ymd(2011-09-01))
library(lubridate)
library(dplyr)
df <- df %>% filter(Month == ymd(2011-09-01))
vincoli.names <- with(df, paste(Casino,Section,MachineType,Denomination, sep="_"))
first <- c("Aries", "Libra")
second <- expand.grid(c('low', 'up'), unique(df$Section), unique(df$Casino))
concat <- function(x) paste0(x[,2], '_', x[,3], '.', x[,1])
second <- concat(second)
third <- expand.grid(c('low','up'), vincoli.names)
third <- with(third, paste(Var2, Var1, sep = "."))
sol <- sols$`2011-09-01`
rownames(sol$con) <- c(first, second, third)
df <- df %>% filter(Month == ymd("2011-09-01"))
vincoli.names <- with(df, paste(Casino,Section,MachineType,Denomination, sep="_"))
first <- c("Aries", "Libra")
second <- expand.grid(c('low', 'up'), unique(df$Section), unique(df$Casino))
concat <- function(x) paste0(x[,2], '_', x[,3], '.', x[,1])
second <- concat(second)
third <- expand.grid(c('low','up'), vincoli.names)
third <- with(third, paste(Var2, Var1, sep = "."))
# load r object with the solutions for each month
load("solutions.RData")
library(lubridate)
library(dplyr)
df <- df %>% filter(Month == ymd("2011-09-01"))
vincoli.names <- with(df, paste(Casino,Section,MachineType,Denomination, sep="_"))
first <- c("Aries", "Libra")
second <- expand.grid(c('low', 'up'), unique(df$Section), unique(df$Casino))
concat <- function(x) paste0(x[,2], '_', x[,3], '.', x[,1])
second <- concat(second)
third <- expand.grid(c('low','up'), vincoli.names)
third <- with(third, paste(Var2, Var1, sep = "."))
sol <- sols$`2011-09-01`
rownames(sol$con) <- c(first, second, third)
shadow_price <- sol$con
vincolo1 <- shadow_price[1:2,]
knitr::kable(vincolo1)
vincolo2 <- shadow_price[3:18,]
knitr::kable(vincolo2)
vincolo3 <- shadow_price[19:dim(shadow_price)[1],]
slots_sum <- group_by(df, Section, tipo, Casino) %>% summarise(sum = sum(numero_macchine))
knitr::kable(head(vincolo3, n = 20))
vincolo3 <- shadow_price[19:dim(shadow_price)[1],]
slots_sum <- group_by(df, Section, tipo, Casino) %>% summarise(sum = sum(numero_macchine))
knitr::kable(head(vincolo3, n = 20))
View(slots_sum)
knitr::kable(vincolo3[vincolo3$actual == vincolo3$bvec & vincolo3$dir == "<=", ])
knitr::kable(sol$allvar)
knitr::kable(vincolo3[vincolo3$actual == vincolo3$bvec & vincolo3$dir == "<=", ])
View(vincolo3)
knitr::kable(vincolo3[vincolo3$actual == vincolo3$bvec & vincolo3$dir == "<=", ] %>% arrange(rownames))
knitr::kable(vincolo3[vincolo3$actual == vincolo3$bvec & vincolo3$dir == "<=", ] %>% arrange(rownames(vincolo3)))
vincolo3 <- shadow_price[19:dim(shadow_price)[1],]
slots_sum <- group_by(df, Section, tipo, Casino) %>% summarise(sum = sum(numero_macchine))
knitr::kable(head(vincolo3, n = 20))
knitr::kable(vincolo3[vincolo3$actual == vincolo3$bvec & vincolo3$dir == "<=", ] %>% arrange(rownames())
knitr::kable(vincolo3[vincolo3$actual == vincolo3$bvec & vincolo3$dir == "<=", ] %>% arrange(rownames()))
knitr::kable(vincolo3[vincolo3$actual == vincolo3$bvec & vincolo3$dir == "<=", ])
vincolo3$rownames <- row.names(vincolo3)
vincolo3 <- vincolo3 %>% arrange(rownames)
knitr::kable(vincolo3[vincolo3$actual == vincolo3$bvec & vincolo3$dir == "<=", ])
vincolo3 <- shadow_price[19:dim(shadow_price)[1],]
vincolo3$rownames <- row.names(vincolo3)
vincolo3 <- vincolo3 %>% arrange(rownames)
slots_sum <- group_by(df, Section, tipo, Casino) %>% summarise(sum = sum(numero_macchine))
knitr::kable(head(vincolo3, n = 20))
vincolo3 <- shadow_price[19:dim(shadow_price)[1],]
vincolo3$rownames <- row.names(vincolo3)
vincolo3[c(7,1:6)]
vincolo3 <- vincolo3 %>% arrange(rownames)
slots_sum <- group_by(df, Section, tipo, Casino) %>% summarise(sum = sum(numero_macchine))
knitr::kable(head(vincolo3, n = 20))
vincolo3 <- shadow_price[19:dim(shadow_price)[1],]
vincolo3$rownames <- row.names(vincolo3)
vincolo3 <- vincolo3[c(7,1:6)]
vincolo3 <- vincolo3 %>% arrange(rownames)
slots_sum <- group_by(df, Section, tipo, Casino) %>% summarise(sum = sum(numero_macchine))
knitr::kable(head(vincolo3, n = 20))
knitr::kable(vincolo3[vincolo3$actual == vincolo3$bvec & vincolo3$dir == "<=", ])
vincolo3 <- shadow_price[19:dim(shadow_price)[1],]
vincolo3$rownames <- row.names(vincolo3)
vincolo3 <- vincolo3[c(7,1:6)]
vincolo3 <- vincolo3 %>% arrange(rownames, dual, dual.reg)
slots_sum <- group_by(df, Section, tipo, Casino) %>% summarise(sum = sum(numero_macchine))
knitr::kable(head(vincolo3, n = 20))
vincolo3 <- shadow_price[19:dim(shadow_price)[1],]
vincolo3$rownames <- row.names(vincolo3)
vincolo3 <- vincolo3[c(7,1:6)]
vincolo3 <- vincolo3 %>% arrange(rownames, dual)
slots_sum <- group_by(df, Section, tipo, Casino) %>% summarise(sum = sum(numero_macchine))
knitr::kable(head(vincolo3, n = 20))
vincolo3 <- shadow_price[19:dim(shadow_price)[1],]
vincolo3$rownames <- row.names(vincolo3)
vincolo3 <- vincolo3[c(7,1:6)]
vincolo3 <- vincolo3 %>% arrange(rownames)
slots_sum <- group_by(df, Section, tipo, Casino) %>% summarise(sum = sum(numero_macchine))
knitr::kable(head(vincolo3, n = 20))
vincolo3 <- shadow_price[19:dim(shadow_price)[1],]
vincolo3$rownames <- row.names(vincolo3)
vincolo3 <- vincolo3[c(7,1:6)]
vincolo3 <- vincolo3 %>% arrange(dual, rownames)
slots_sum <- group_by(df, Section, tipo, Casino) %>% summarise(sum = sum(numero_macchine))
knitr::kable(head(vincolo3, n = 20))
knitr::kable(vincolo3[vincolo3$actual == vincolo3$bvec & vincolo3$dir == "<=", ])
vincolo3 <- shadow_price[19:dim(shadow_price)[1],]
vincolo3$rownames <- row.names(vincolo3)
vincolo3 <- vincolo3[c(7,1:6)]
vincolo3 <- vincolo3 %>% arrange(rownames, dual)
slots_sum <- group_by(df, Section, tipo, Casino) %>% summarise(sum = sum(numero_macchine))
knitr::kable(head(vincolo3, n = 20))
knitr::kable(vincolo3[vincolo3$actual == vincolo3$bvec & vincolo3$dir == "<=", ])
vincolo3 <- shadow_price[19:dim(shadow_price)[1],]
vincolo3$rownames <- row.names(vincolo3)
vincolo3 <- vincolo3[c(7,1:6)]
vincolo3 <- vincolo3 %>% arrange(dual, rownames)
slots_sum <- group_by(df, Section, tipo, Casino) %>% summarise(sum = sum(numero_macchine))
knitr::kable(head(vincolo3, n = 20))
knitr::kable(vincolo3[vincolo3$actual == vincolo3$bvec & vincolo3$dir == "<=", ])
20*26836
46+9199
46*9199
vincolo3 <- shadow_price[19:dim(shadow_price)[1],]
vincolo3$rownames <- row.names(vincolo3)
vincolo3 <- vincolo3[c(7,1:6)]
vincolo3 <- vincolo3 %>% arrange(rownames, dual)
slots_sum <- group_by(df, Section, tipo, Casino) %>% summarise(sum = sum(numero_macchine))
knitr::kable(head(vincolo3, n = 20))
knitr::kable(vincolo3[vincolo3$actual == vincolo3$bvec & vincolo3$dir == "<=", ])
vincolo3 <- vincolo3 %>% arrange(dual)
knitr::kable(vincolo3[vincolo3$actual == vincolo3$bvec & vincolo3$dir == "<=", ])
vincolo3 <- vincolo3 %>% arrange(dual)
vincolo3 <- vincolo3 %>% mutate(incremento = dual * dual.reg)
knitr::kable(vincolo3[vincolo3$actual == vincolo3$bvec & vincolo3$dir == "<=", ])
vincolo3 <- vincolo3 %>% mutate(incremento = dual * dual.reg)
vincolo3 <- vincolo3 %>% arrange(desc(dual.reg))
knitr::kable(vincolo3[vincolo3$actual == vincolo3$bvec & vincolo3$dir == "<=", ])
vincolo3 <- vincolo3 %>% mutate(incremento = dual * dual.reg)
vincolo3 <- vincolo3 %>% arrange(desc(incremento))
knitr::kable(vincolo3[vincolo3$actual == vincolo3$bvec & vincolo3$dir == "<=", ])
Coef_FO <- sol$allvar
rm(Coef_FO)
coef_FO <- sol$allvar
View(coef_FO)
coef_FO <- sol$allvar
nomi <- rownames(df)
View(df)
vincoli.names
rm(nomi)
coef_FO <- sol$allvar
coef_FO$variabili <- vincoli.names
View(coef_FO)
View(coef_FO)
View(vincolo1)
154+78
156+16+2+78
coef_FO <- sol$allvar[1:78] #exclude slack variable
coef_FO <- sol$allvar[1:78,] #exclude slack variable
coef_FO$variabili <- vincoli.names
View(coef_FO)
coef_FO <- sol$allvar[1:78,] #exclude slack variable
coef_FO$variabili <- vincoli.names
coef_FO <- coef_FO %>% arrange(variabili)
coef_FO <- sol$allvar[1:78,] #exclude slack variable
coef_FO$variabili <- vincoli.names
coef_FO <- coef_FO %>% select(variabili, min.c, max.c) %>% arrange(variabili)
sol$allvar[1:78,]
coef_FO <- sol$allvar[1:78,] #exclude slack variable
coef_FO$variabili <- vincoli.names
coef_FO <- coef_FO %>% select(variabili, opt, min.c, max.c) %>% arrange(variabili)
coef_FO <- sol$allvar[1:78,] #exclude slack variable
coef_FO$variabili <- vincoli.names
coef_FO <- coef_FO %>% select(variabili, min.c, opt, max.c) %>% arrange(variabili)
sol$allvar[1:78,]
coef_FO <- sol$allvar[1:78,] #exclude slack variable
coef_FO$variabili <- vincoli.names
coef_FO <- coef_FO %>% select(variabili, min.c, cvec, max.c) %>% arrange(variabili)
coef_FO <- sol$allvar[1:78,] #exclude slack variable
coef_FO$variabili <- vincoli.names
coef_FO <- coef_FO %>%
select(variabili, min.c, cvec, max.c) %>%
arrange(variabili) %>%
mutate(incremento_max = max.c - cvec, decremento_max = cvec - min.c)
11095+9199
11095-97
summary(coef_FO$incremento_max)
summary(coef_FO$decremento_max)
ggplot2::ggplot(coef_FO, aes(x=incremento_max)) + geom_histogram
ggplot(coef_FO, aes(x=incremento_max)) +
geom_histogram()
library(lubridate)
library(dplyr)
library(ggplot2)
ggplot(coef_FO, aes(x=incremento_max)) +
geom_histogram()
ggplot(coef_FO, aes(x=incremento_max)) +
geom_histogram() +
stat_bin(bins = 30)
coef_FO[coef_FO$incremento_max == -inf,] <- 10000000
coef_FO[coef_FO$incremento_max == "-inf",] <- 10000000
View(coef_FO)
coef_FO[coef_FO$incremento_max == "inf",] <- 10000000
View(coef_FO)
coef_FO[coef_FO$incremento_max == "Inf",] <- 10000000
View(coef_FO)
ggplot(coef_FO, aes(x=incremento_max)) +
geom_histogram() +
stat_bin(bins = 30)
coef_FO <- sol$allvar[1:78,] #exclude slack variable
coef_FO$variabili <- vincoli.names
coef_FO <- coef_FO %>%
select(variabili, min.c, cvec, max.c) %>%
arrange(variabili) %>%
mutate(incremento_max = max.c - cvec, decremento_max = cvec - min.c, Casino =)
coef_FO <- sol$allvar[1:78,] #exclude slack variable
coef_FO$variabili <- vincoli.names
coef_FO <- coef_FO %>%
select(variabili, min.c, cvec, max.c) %>%
arrange(variabili) %>%
mutate(incremento_max = max.c - cvec, decremento_max = cvec - min.c, Casino =)
coef_FO <- sol$allvar[1:78,] #exclude slack variable
coef_FO$variabili <- vincoli.names
coef_FO <- coef_FO %>%
select(variabili, min.c, cvec, max.c) %>%
arrange(variabili) %>%
mutate(incremento_max = max.c - cvec, decremento_max = cvec - min.c)
boxplot(coef_FO$decremento_max)
summary(coef_FO$incremento_max)
summary(coef_FO$decremento_max)
summary(coef_FO$incremento_max)
print("")
summary(coef_FO$decremento_max)
summary(coef_FO$incremento_max)
print("/n")
summary(coef_FO$decremento_max)
summary(coef_FO$incremento_max)
summary(coef_FO$decremento_max)
cat("distribuzione incremento massimo", summary(coef_FO$incremento_max), sep = "/n")
summary(coef_FO$decremento_max)
cat("distribuzione incremento massimo", summary(coef_FO$incremento_max), "\ndistribuzione decremento massimo", summary(coef_FO$decremento_max))
cat("distribuzione incremento massimo\n")
summary(coef_FO$incremento_max)
cat("distribuzione decremento massimo\n")
summary(coef_FO$decremento_max))
cat("distribuzione incremento massimo\n")
summary(coef_FO$incremento_max)
cat("distribuzione decremento massimo\n")
summary(coef_FO$decremento_max)
